/*
	Copyright (C) by Franksoft 2012.

	This file is part of the YSLib project, and may only be used,
	modified, and distributed under the terms of the YSLib project
	license, LICENSE.TXT.  By continuing to use, modify, or distribute
	this file you indicate that you have read the license and
	understand and accept it fully.
*/

/*!	\file NPL.txt
\ingroup Documentation
\brief NPL 规格说明。
\version r291;
\author FrankHB<frankhb1989@gmail.com>
\since YSLib build 304 。
\par 创建时间:
	2012-04-25 10:34:20 +0800;
\par 修改时间:
	2012-04-25 22:41 +0800;
\par 文本编码:
	UTF-8;
\par 模块名称:
	Documentation::NPL;
*/


/*

@0 体例和适用范围：
引用标记参见 [Documentation::CommonRules @@0.1] 。
关于实现编码细节和其它规范参见 [Documentation::Designation @@0.1] 。
本文档适用于 NPL 及实现。

@1.1 设计的基本原理、表达形式和抽象：
设计的出发点：构建一个可用计算机实现的语言。
原始目的：在以标准 C++ 环境（宿主实现）的程序框架中嵌入配置和脚本操作。
扩展目的：渐进地向独立的计算机软件系统演进，探究能适用于各个领域并以计算机实现的通用语言。
本文描述基于此出发点的 NPL(Name Protocoling Language) 及其参考实现。

@1.2 理论背景、工具和依据：
基本内容参见 [Documentation::CommonRules @@2.1] 。

@1.2.1 组织概念模型：
略。

@1.2.3 设计意义：
参见 [Documentation::Designation @@1.2.3] 。

@1.3 构建原则：
基本内容参见 [Documentation::CommonRules @@2.2] 。

@1.3.2 可移植性相关：
基本内容参见 [Documentation::CommonRules @@2.2.2] 。
语言使用规则参见 [Documentation::CommonRules @@5] 。

@1.3.2 标准库/系统库使用：
参见 [Documentation::Designation @@1.3.2] 。

@1.3.3 可维护性和架构设计：
基本内容参见 [Documentation::CommonRules @@2.2.3] 。
语义相关的架构参见 [Documentation::CommonRules @@2.3.2] 。

@1.3.4 实现功能特征概述：
便于扩展。
尽可能地平台无关，且注重效率。
能够保持必要的运行时安全性。
实现一部分的通用较高级功能。

@1.4 领域设计原则：

@1.4.1 原则性描述：
所谓“哲学”，但不一定是关于设计的。
本体论：存在即本质；
价值观：
懒惰即正义；
不为不需要的特性付出代价；
（略；）
形而上学：不确定具体实现；语言实现即库设计；
方法论：
适时收缩理论长度以照顾可操作性（注意断言一个优化过早自身可能就是一个过早的优化）；
不必要确定具体需求（只限定需求范围：能使用图灵机实现部分语义的任务）。

@1.4.2 阶段性目标：
确定系属分类；
确定实现方法；
必要的自然语言描述。

@1.4.3 语义方法：
语义学方法：指称语义、公理语义、操作语义。
非确定语义：经验语义，不需要使用自然语言解释的部分。

@2 基本概念约定：
描述中可能涉及上下文相关的略称参见 @2.3 。

@2.1 通用约定：
关于“语言”补充的<相关范畴/上下文>基本概念和约定。
除非有其它说明，适用于任意上下文。

@2.1.1 [<自指><名词>] ：
实体(entity) ：任意被自然语言表达的目标；不需要通过自然语言先验定义；参见经验语义。
语义(semantics) ：参见经验语义。
经验(experience) ：参见哲学或一般等价的经验语义。
范畴(category) ：参见范畴论。
态射(morphism) ：参见范畴论。
归纳(induction) ：一种态射，可操作性参见经验语义。
方法学(methodology) ：一个归纳经验得到的范畴；参见哲学或一般等价的经验语义。
方法(method) ：方法学的一个子范畴；可操作性参见经验语义。
概念(concept) ：参见形式逻辑学。
上下文(context) ：一种概念范畴适用的态射；参见经验语义。

@2.1.2 [<非自指>] ：
形式(form) ：参见经验语义和数学。
<概念>内涵：参见形式逻辑学。
<概念>外延：参见形式逻辑学。
<概念>定义(definition) ：确定概念内涵和外延的方法；参见任意一种形式逻辑学。
集合(set) ：参见 NBG 集合论。
序列(sequence) ：有序集合。
类(class) ：参见 NBG 集合论和范畴论。
真类(proper class) ：参见 NBG 集合论和范畴论。
状态(state) ：参见经验语义和数学。
<动词>抽象(abstracting) ：通过经验语义定义概念范畴或集合的方法。
<名词>抽象(abstraction) ：<动词>抽象的结果。
<动词>封装(encapsulating) ：从某一个范畴中抽象一个子范畴的方法。
<名词>封装(encapsulation) ：<动词>封装的结果。
接口(interface) ：一种封装，参见软件工程学。
实现(implementation) ：一种封装，参见软件工程学。
重用(reusing) ：参见经验语义和软件工程学。
不变量(invariable) ：参见数学和契约式程序设计。
<动词>派生(deriving) ：基于重用的操作。
<名词>派生(derivation) ：<动词>派生的结果。
<语言>接口(<language>interface) ：和表达语义有关的语言的可见的特征。
<语言>实现(<language>implementation)：对于语言表达语义的表达。
<语言>人类接口(human interface) ：语义仅对人类有意义（内容改变时可以导致语义的差异性），不提供为涉及作为图灵机实现的语言接口。
<语言>机器接口(machine interface) ：对于机器（或特定语言实现的特定部分）有意义的语言接口。注意不同语言实现组成部分可以不同。例如，对于 C 预处理器而言， C 源代码中的空白符是机器接口，而对于翻译器来说则不是。就源代码而言，机器接口总是人类接口的子集。
语言特性(language feature) ：作为功能提供的人类接口。

@2.2 领域约定：
适用于上下文 <NPL> 。
广义实体：<通用约定>实体。语言抽象的目标，不另行定义（意义最终取决于自然语言）。
名称(name) ：一种在 NPL 可表达的字符串，受名称语法约束。
实体(entity) ：非名称的广义实体。
派生语言实现(derived language implementation) ：派生已有实现的部分或全部得到的语言实现。以下简作“派生实现”。
具体语言实现(concreate language implementation) ：在机器上能够最终表达为指令流或其它形式表达可计算性的实现，一般应为程序。
抽象语言实现(abstract language implementation) ：非具体语言实现的语言实现。形式意义的标准定义的语言属于此类。
代码(code)：任意有限的语言的实例片段。
伪代码(pseudo code)：抽象语言实现的语言的代码。注意习惯上和具体语言实现代码完全一致的代码可以不作为伪代码考虑。
实现环境(environment of implementation) ：对应于特定语言实现的特定不变状态（对于机器来说可以是配置项，对于人来说不确定，所以一般忽略）的集合。
行为(behavior) ：语言实现的表现。基于可操作性考虑，一般仅约束机器实现。
规则(rule) ：用于确定行为的描述。
约束(constraint) ：可被形式表达，用于限制和明确行为的规则。不一定使用形式表达。
违反(violation) ：对约束指定的条件的不满足。
诊断消息(diagnostic message) ：用于和用户交互的提示性信息。
未定义的(undefined) ：可能导致违反约束但不保证具有诊断消息的。表示置于规则下的行为等不可预测。
未指定的(unspecified) ：在各个实现中可能存在的。不应假定不同实现具有完全一致的特性。
由实现定义的(implementation-defined) ：取决于各个具体实现的。
由派生实现定义的(derived-implementation-defined) ：取决于各个具体派生实现的。

@2.3 略称：
仅在不致混淆时使用。
实现(implementation) ：语言实现。
环境(environment) ：实现环境。
派生实现(derived implementation) ：派生语言实现。

@3 文法：

@3.1 基本概念：
字符(character) ：组成语言代码的最小实体。
基本翻译单元(basic transation unit) ：任意连续字符的有限序列（可以是空序列）。
翻译单元(translation unit) ：基本翻译单元的集合，之间满足由派生实现定义的规则。

@3.2 字符集：
字符集(character set) ：对于一个实现而言不变的字符的有限集合。
基本字符集(basic character set) ：实现环境必须支持的字符集。具体由派生实现定义。
其它同 ISO/IEC 14882:2011 对 character 和 character set 的有关定义。

@3.3 词法：

@3.3.1 基本词法构造：
<token> ::= <literal> | <$punctuator> | <$identifier>
记号(token) ：代码中非空白符分隔的字符序列。
字面量(literal) ：一种记号，参见 @3.3.3 。
标点(punctuator) ：由派生实现定义的特定字符序列的集合，起分隔其它记号的作用，具有一定语义功能。
标识符(identifier) ：除字面量和标点以外的标识符。
可以保证 ISO/IEC 14882:2011 的 identifier 的定义，或在上述标识符中插入字符 $ 构造得到的标识符属于 NPL 标识符。

@3.3.2 转义序列和字符序列：
<char-escape-content-seq> ::= <$single-escape-char> | <$escape-prefix-char><$escape-content-seq>
<char-seq> ::= <$literal-char> | \<char-escape-seq>

@3.3.3 字面量：
<literal-content> ::= <char-seq> | <literal-char-seq><literal-data>
<data-literal> ::= "<literal-content>"
<code-literal> ::= '<literal-content>'
<string-literal> ::= <code-literal> | <data-literal>
<literal> ::= <string-literal> | <$derived-impldef-literal>
代码字面量(code literal) ：以 ' 作为起始和结束字符的记号。
数据字面量(data literal) ：以 " 作为起始和结束字符的记号。
字符串字面量(string literal) ：代码字面量或数据字面量。
字面量：字符串字面量或其它由派生实现定义的记号。

@3.3.4 词法分析规则：
输入翻译单元，输出记号序列。
输出规则（按优先顺序）：
断行连接：反斜杠之后紧接换行符的双字符序列视为续行符，会被删除；
反斜杠转义：连续两个反斜杠被替换为一个反斜杠；
引号转义：反斜杠之后紧接单引号或双引号时，反斜杠会被删除；
字面量：未被转义的单引号或双引号后进入字面量解析状态，无视以下规则，直接逐字节输出原始输入，直至遇到对应的另一个引号。
窄字符空白符替换：单字节空格、水平/垂直制表符、换行符被替换为单一空格；回车符会被忽略；
原始输出：其它字符序列逐字节输出。

@3.4 语法：

@3.4.1 基本语法构造：
expression ::= token | token expression
表达式(expression) ：受表达式语法约束的记号序列。

@3.4.2 表达式：

@3.4.3 语句：

@4 语义：

@4.1 基本概念：
范围(range) ：一个连续区间。此处“连续”的概念由派生实现定义。
作用域(scope) ：可由词法分析实现(@5.3) 确定的代码片段的位置范围。
对象(object) ：表示可被线性连续存储的状态的集合的实体。
声明(declaration) ：引入名称的表达式。
变量(variable) ：通过声明引入的实体。
常量(constant) ：满足某种不变量的约束的实体。具体由派生实现定义。注意不和对立变量。
值(value) ：表达式关联的实体。
副作用(side effect) ：对环境状态的改变。
求值(evaluation) ：实现对表达式的处理过程，包括值的计算和副作用的产生。
规约(reduction) ：以表达式替代另一个表达式的过程。

@4.2 语义规则：
所有不需要诊断消息的规则由派生实现定义（即以下规则不产生未定义行为）。

@5 语言实现：

@5.1 领域语义支持：
位(bit) ：表示二进制存储的最小单位，具有 0 和 1 两种状态。
字节(byte) ：基本字符集中一个字符需要的最少的存储空间。

@5.2 实现约定：
一字节至少占用 8 个二进制位。

@5.2.1 参考实现约定：
一字节占用 8 位。
翻译单元同基本翻译单元。
字面量同字符串字面量。
标点为单字节序列。

@5.3 词法分析：
参见 @3.1.3 和参考实现。

@6 编码风格导引：
仅叙述之前章节未涉及的内容。
参见 [Documentation::CommonRules @@6] 。

@7 一般实现导引：

@7.1 程序实现：
程序是语言的派生。实现程序即在语言的基础上指定派生规则。

*/
////

