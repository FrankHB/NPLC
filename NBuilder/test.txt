"#", "(C) 2017-2022 FrankHB.",
"NPLC basic derivation extension and test module.";

"NOTE", "For the test purpose, this file is deliberatedly kept as UTF-8+BOM",
	"with LF as the EOL mark.";

$import&! std.io newline puts putss iput;
$import&! std.strings ++ string<- string-empty? string->symbol;
$import&! std.math - <=? + =? <? >? * max min add1;

$defl! display/newline (&x) (display (forward! x); () newline);
$defl! write/newline (&x) (write (forward! x); () newline);

"XXX", "Assume the move-after state is deterministic of a stable value,",
	" which is the empty list at current.";
$def! moved? null?;
"XXX", "Assume moved-after states are not the unit value,",
	"otherwise the expectations on equality to the value is false negative.";
$def! unit (first (() make-encapsulation-type)) #inert;

$def! nil ();
$def! nill list% nil;
$def! nilvl list nil;
$def! &nilr rest& nill;
$def! &nilvr rest& nilvl;

$def! SS_TestOpts_QuickFail #t;
$def! report-failure $if SS_TestOpts_QuickFail raise-error puts;
$defl! pass (.) puts "PASS.";
$defl! fail-on-check (&expr &res) $sequence
	(puts "FAIL: Check failed, with the expression:")
	(write/newline expr)
	(puts "  with the result:")
	(display/newline res)
	(report-failure "Test case failed.");
$defl! fail-on-expect (&expr &res &expected) $sequence
	(puts "FAIL: Check failed, with the expression:")
	(write/newline expr)
	(puts "  with the result:")
	(display/newline (forward! res))
	(puts "  expected result:")
	(display/newline (forward! expected))
	(report-failure "Test case failed.");
$defv! $check (.&expr) d
	$let ((&res eval expr d))
		$if res (pass (forward! res)) (fail-on-check expr (forward! res));
$defv! $check-not (.&expr) d
	$let ((&res eval expr d))
		$if res (fail-on-check expr (forward! res)) (pass (forward! res));
$defv! $expect (&expected-expr .&expr) d
	$let ((&res eval expr d) (&expected eval expected-expr d))
		$if (equal? res expected) (pass (forward! res))
			(fail-on-expect expr (forward! res) (forward! expected));
$defv! $expect-moved (.&expr) d
	$let ((&res eval expr d))
		$if (moved? res) (pass (forward! res))
			(fail-on-expect expr (forward! res) ());
$defl! info (.&msgs) apply putss (list* "Test case: " (forward! msgs));
$defl! subinfo (.&msgs) apply putss (list* "Sub test case: " (forward! msgs));

$def! __make-stdenv copy-environment;
$defl! list-restv (&x) list (restv x);
$defu! for-each for-each-rtl for-each-ltr;
$defl! first-length (&l) list-length (first l);
$defl! maxlens (&l) accr l null? (first-length l) first-length rest& max;
$defl! minlens (&l) accr l null? (first-length l) first-length rest& min;
$defl! accr-n (&l &k &base &head &tail &sum)
(
	$defl! aux (&l n) ($if (=? n 0) (forward! base) (sum (head (forward l))
		(aux (tail (forward l)) (- n 1))));
	aux (forward! l) k
);
$defl! enlist-n (&ls &k &head &tail) accr-n (forward! ls) k () head tail cons;
$def! mapn $let ((&se make-environment (() get-current-environment))) wrap
(
	$set! se cxrs $lambda/e (weaken-environment se) (&ls &sel)
		enlist-n (forward ls) (list-length ls) ($lambda (&l) sel (firstv l))
			restv;
	$vau/e se (&n &appv .&ls) d enlist-n (move! ls) n
		($lambda (&ls) apply appv (cxrs (forward! ls) first) d)
			($lambda (&ls) cxrs ls restv)
);
$defw! map-fromn (&appv .&ls) d
	apply mapn (list* (minlens ls) appv (move! ls)) d;
$defw! map-strict (&appv .&ls) d
	apply mapn (list* (maxlens ls) appv (move! ls)) d;

$defl! test (&i)
(
	$def! q-a 1;
	$def! q-b 4;
	$def! q-e;
	$def! q-li list% q-a 2;
	$def! q-li2 list% 3 q-a;
	$def! q-li3 list q-li 2;
	$def! q-li4 list q-li2 3 4 5;
	putss "Test case " (itos i) ":";
	$cond
	((eqv? i 1) (
		info "sanity";
		subinfo "empty expression";
		$expect ();
		subinfo "zeros;" " '+0' and '-0' fixed since b931";
		$expect 0 0;
		$expect 0 +0;
		$expect 0 -0;
		$expect 0 00;
		$expect 0.0 0.0;
		$expect 0.0 +0.0;
		$expect 0.0 0.00;
		$expect 0.0 00.0;
		$expect -0.0 -0.0;
		subinfo "id expressions";
		$expect 42 $let ((a 42)) a;
		$expect 42 $let (('' 42)) '';
		$expect 42 $let ((' ' 42)) ' ';
		subinfo "null?";
		$check null? ();
		$check null? nil;
		$check null? nilr;
		$check null? nilvr
	))
	((eqv? i 2) (
		info "function calls";
		subinfo "basic combiner calls";
		$let ()
		(
			$defl! gg fm apply - (idv fm);
			$defv! $gg fm #ignore
				eval (list* - fm) (() get-current-environment);
			$expect (- 0 1) gg 2 3;
			$expect (- 0 1) $gg 3 4
		);
		subinfo "combiner rvalue calls: tail calls;" " fixed since b856";
		$expect () ($lambda (x) forward x) ();
		$expect () ($lambda (x) ($lambda (y) idv y) x) ();
		$expect () ($lambda (x) ($lambda (y) id y) x) ();
		$expect "" ($lambda (x) ($lambda (y) ++ y) x) "";
		$expect () ($lambda (x) ($lambda (y)) x) ();
		$expect () ($lambda (x) ($lambda (.)) x) ();
		$expect () ($lambda (x) ($lambda (.) ()) x) ();
		$expect () ($lambda (x) ($lambda (y) y) x) ();
		$expect () ($lambda (x) ($lambda (y) (idv y)) x) ();
		$expect ()
			$let () ($def! foo $lambda (z) z;
				($lambda (x) ($lambda (y) foo y) x) ());
		$expect () ($lambda (x) ($lambda (y) ($lambda (z) z) y) x) ();
		$expect () $let () ($lambda ((&x .)) x) nilvl;
		subinfo "combiner subobjects of vau prvalue incorrectly moved;"
			" fixed since b953";
		$let ((f $lambda (x) x))
		(
			(idv (unwrap f)) 1;
			$expect 42 (f 42)
		);
		subinfo "apply";
		$expect 42 apply list% 42;
		$expect (list 1 2) apply list% (list% 1 2);
		$expect (cons 1 2) apply list% (cons% 1 2);
		$expect (list* 1 2 3) apply list% (list* 1 2 3);
		subinfo "apply nocopy functions;" " fixed since b944";
		apply (() make-nocopy-fn) ();
	))
	((eqv? i 3) (
		info "recursive function calls";
		subinfo "Fibonacci";
		$let ()
		(
			$defl! fib (&n) $if (<=? n 1) 1 (+ (fib (- n 1)) (fib (- n 2)));
			$expect 8 fib 5;
		);
		subinfo "Hofstadter Female and Male sequences";
		$let ()
		(
			$def! (F M) list
				($lambda (&n) $if (=? n 0) 1 (- n (M (F (- n 1)))))
				($lambda (&n) $if (=? n 0) 0 (- n (F (M (- n 1)))));
			$expect 5 F 7;
			$expect 4 M 7
		)
	))
	((eqv? i 4) (
		info "basic object operations";
		subinfo "copy elision";
		$let ()
		(
			$defl! test-elision (f) $let ((x () make-nocopy)) f (expire x);
			test-elision idv;
			subinfo "collapse copy elision on xvalues;"
				" fixed derivation since b939";
			test-elision collapse
		);
		subinfo "equal?";
		$check equal? () ();
		$check equal? 1 1;
		$check equal? (list 2) (list 2);
		$check equal? (list% q-a) (list q-a);
		$check-not equal? 1 2;
		$check-not equal? (list 1 2) 3;
		$check-not equal? (list 1 2) (list 3 4);
		$check equal? (cons q-a 2) (cons% q-a 2);
		$check equal? (cons% q-a 2) (cons% q-a 2);
		$check-not equal? (cons q-a 2) (cons% q-a 3);
		$check-not equal? (cons% q-a 2) (cons% q-a 3);
		subinfo "equal? regular result;" " fixed native since b948";
		$check equal? #t (equal? (list 1 2) (list 1 2));
		subinfo "equal? + fwd?";
		$let ((fwd? $vau% (&x) d
			($lambda% (%v) bound-lvalue? ($resolve-identifier v))
				(eval% x d)))
			$expect (list% #f #f #t #t #f)
				list% (fwd? 1) (fwd? ()) (fwd? fwd?) (fwd? (id fwd?))
					(fwd? (idv fwd?));
		subinfo "simple recursive thunks without thunk cleanup";
		$expect 1 $let () ($defrec! a 1; a);
		$expect 1 $let () ($defrec! (a a) list 1 1; a);
		$let () ($defrec! (&a b) list b ($lambda () 1));
		subinfo "$defrec!;" " fixed since b897";
		$let () ($defrec! (&a b) list b ($lambda () 1));
		$expect 1 $let () ($defrec! (b &a) list ($lambda () 1) b; () b)
	))
	((eqv? i 5) (
		info "reference and assignment operations";
		$let* (((a b) list 1 2) (li list% a 2) (lie list% (expire a) 2))
		(
			subinfo "expecting different results for 'first&' and 'first@'";
			$check-not eq? (first& li) (first@ li);
			subinfo "reference collapsing";
			$let ((lic list% (as-const a) 2))
			(
				$check reference? (first@ li);
				$check uncollapsed? (first@ li);
				$check reference? (idv (first@ li));
				$check-not uncollapsed? (idv (first@ li));
				$check-not unique? (collapse (first@ li));
				$check-not unique? (collapse (first@ lie));
				$check-not unique? (collapse (expire (first@ li)));
				$check unique? (collapse (expire (first@ lie)));
				$check modifiable? (collapse (first@ li));
				$check-not modifiable? (collapse (first@ lic));
				$check-not modifiable? (collapse (as-const (first@ lic)));
				subinfo "collapse safety;" " fixed derivation since b939";
				$let ((a (collapse (() make-nocopy))) (b (collapse 42)))
					$expect 42 b;
				subinfo "collapsed nonmodifying values;"
					" fixed derivation since b939";
				$check-not modifiable? (collapse (as-const (first@ li)));
				subinfo "collapsed value category;" " fixed since b925";
				$check-not unique? (collapse (first@ lie))
			);
			subinfo "expecting prvalue for reference to reference";
			$expect 1 idv (idv (first@ li));
			$expect 1 idv (idv ((wrap ($vau% (%x) #ignore x)) (first@ li)));
			$expect 1 idv (idv (($lambda% (%x) x) (first@ li)));
			subinfo "expecting a reference to object";
			assign%! b (first@ li);
			display/newline b;
			$let ((li2 list% 3 4))
			(
				subinfo "expecting a reference to object as first element";
				set-first%! li2 (first@ li);
				display/newline li2;
				subinfo "expecting a reference to reference";
				assign@! b (first@ li);
				display/newline b;
				subinfo "expecting a reference to reference as first element";
				set-first@! li2 (first@ li);
				display/newline li2
			);
			$rem "Following shall signal an error.";
			$rem set-first%! (first@ li);
			subinfo "id and reference tests";
			$def! a 1;
			$def! b 2;
			$def! li list% a 2;
			assign@! b (first@ li);
			$check-not eqv? (id b) 1;
			$def! b 2;
			$def! li list% a 2;
			assign@! b (first@ li);
			$check reference? (id b);
			$def! b 2;
			$def! li list% a 2;
			assign@! b (first@ li);
			$check uncollapsed? (id b);
			$def! b 2;
			$def! li list% a 2;
			assign@! b (first@ li);
			$check eqv? (idv (idv (id b))) 1;
			subinfo "idv move! tests";
			$check eqv? (idv (move! 42)) 42;
			$def! b 2;
			$def! li list% a 2;
			assign@! b (first@ li);
			$check eqv? (idv (move! b)) 1;
			$def! b 2;
			$def! li list% a 2;
			assign@! b (first@ li);
			$check-not reference? (idv (move! b));
			subinfo "move! tests";
			$def! b 2;
			$def! li list% a 2;
			assign@! b (first@ li);
			$check eqv? (move! b) 1;
			$def! b 2;
			$def! li list% a 2;
			assign@! b (first@ li);
			$check reference? (move! b);
			$def! b 2;
			$def! li list% a 2;
			assign@! b (first@ li);
			$check-not uncollapsed? (move! b)
		);
		subinfo "preventing non-first-class temporary objects;"
			" fixed since b925";
		$let ()
		(
			$defl! test-nt (&f)
				$let ((&t (idv unit)) (&u (idv unit)) (&v (idv unit)))
				(
					$def! x f t;
					forward! x;
					$expect unit x;
					assign@! x (f u);
					forward! x;
					$expect unit x;
					assign%! x (f v);
					forward! x;
					$expect unit x
				);
			test-nt move!;
			test-nt transfer!;
			test-nt forward!
		)
	))
	((eqv? i 6) (
		info "environment operations";
		subinfo "eval";
		$expect 42 eval 42 (() get-current-environment);
		$expect 42 eval% 42 (() get-current-environment);
		subinfo "eval lists";
		$expect 1 eval (list 1) (() get-current-environment);
		$expect (cons 1 2) eval (list cons 1 2) (() get-current-environment);
		$expect (list 1 2) eval (list list 1 2) (() get-current-environment);
		subinfo "freeze-environment!";
		$let ((e0 make-environment (() get-current-environment)))
		(
			$set! e0 q0 0;
			$def! e1 make-environment e0;
			$set! e1 q1 1;
			$set! e1 q2 2;
			freeze-environment! e0;
			eval ($quote (
				$rem assign! q1 1;
				$rem $def! q2 2
			)) e1
		);
		subinfo "copy-environment: Y combinatior";
		$let ()
		(
			$defl! Y (f) ($lambda (&h) h h)
				(wrap ($vau/e (() copy-environment) (x) #ignore f
					(wrap ($vau/e (() copy-environment) z #ignore
						(apply (x x) (idv z))))));
			$def! fact Y ($lambda (&f)
				wrap ($vau/e (() copy-environment) (z) #ignore
					$if (eqv? z 0) 1 (* z (f (- z 1)))));
			$def! fib Y ($lambda (&f)
				wrap ($vau/e (() copy-environment) (n) #ignore
					$if (<? n 2) n (+ (f (- n 1)) (f (- n 2)))));
			(list (fact 5) (fib 5))
		)
	))
	((eqv? i 7) (
		info "combiner operations";
		subinfo "combiner equality";
		$check eqv? (idv idv) idv;
		$check-not eqv? (wrap idv) idv;
		$check eqv? (wrap idv) (wrap idv);
		$check eqv? (wrap% idv) (wrap idv);
		$check eqv? (wrap% idv) (wrap% idv);
		$check eqv? (unwrap unwrap) (unwrap unwrap);
		$let ((idv wrap $quote))
		(
			$def! idv wrap $quote;
			$check eqv? (unwrap idv) $quote;
			$check eqv? (unwrap (idv idv)) $quote;
			$check eqv? (unwrap idv) (unwrap (idv idv));
			$check eqv? (wrap (unwrap idv)) idv
		);
		subinfo "wrap/unwrap;" " fixed since b859";
		((unwrap (unwrap (wrap (wrap ($quote)))))) ($quote id);
		subinfo "sanity on irregular representations;" " fixed since b876";
		$let ()
		(
			$def! f idv;
			$def! e () make-environment;
			$set! e $f unwrap f;
			$set! e &$fr unwrap f;
			$def! $uf eval% ($quote $f) e;
			$def! $ufr eval% ($quote $fr) e;
			$def! &$urf eval% ($quote $f) e;
			$def! &$urfr eval% ($quote $fr) e;
			$def! &$urfri eval% (list $resolve-identifier ($quote $fr)) e;
			$undef! e;
			$uf 1;
			$ufr 2;
			$rem "Undefined behavior:"
				"Expected failure on NPL_NPLA_CheckTermReferenceIndirection:"
				($urf 3);
			$rem "The following evaluations rely on correctly returning an"
				" object of irregular representation, when only one of '$urfr'"
				" and '$urfri' is defined (and thus the terms in the irregular"
				" representation are not shared elsewhere).";
			$urfr 4;
			$rem $urfri 5
		);
		subinfo "self-evaluation on nested one-element list of irregular"
			" representations;" " fixed since b945";
		$expect (unwrap id)
			eval% (list% (unwrap id)) (() get-current-environment);
		subinfo "test for ref&, etc.";
		$let* ((x "xx") (rx ref& x))
		(
			$def! $f1 wrap ($vau/e (() get-current-environment) () env
				eval (list $sequence (puts x) (assign! x "yy") (puts x)
					(string<- rx "ee") (puts rx)) env);
			() $f1
		)
	))
	((eqv? i 8) (
		info "make-encapsulation-type";
		subinfo "encapsulation values";
		$let ()
		(
			$def! (e p? d) () make-encapsulation-type;
			p? 1;
			$def! enc e 1;
			$check p? enc;
			$check-not p? "str";
			$expect 1 d enc;
			$expect 2 d (e 2);
			$check eqv? (e (list 1 2)) (e (list 1 2));
			$check-not eqv? (e (list 1 2)) (e (list 3 4))
		);
		subinfo "encapsulation temporary values";
		$let ((u unit) (&lt unit) (&t (idv unit)))
		(
			$def! (e% #ignore d) () make-encapsulation-type;
			$def! o e% u;
			forward! (d o);
			$expect unit d o;
			$def! o e% lt;
			forward! (d o);
			$expect unit d o;
			$def! o e% t;
			forward! (d o);
			$expect-moved d o
		);
		subinfo "encapsulation equality";
		$let ()
		(
			$def! (e #ignore d) () make-encapsulation-type;
			$def! x e 1;
			$def! y e 2;
			$def! z e 2;
			$check-not eqv? x y;
			$check eqv? y z
		)
	))
	((eqv? i 9) (
		info "$sequence derivations";
		$let ()
		(
			$defl! test-sequence ($f)
			(
				$def! x "x";
				$f (puts "a") (puts x) (puts "b") (puts x)
			);
			subinfo "with $set! and $lambda%";
			$let ()
			(
				$def! $sequence
					($lambda (&se) ($lambda #ignore $vau/e% se exprseq d
						$if (null? exprseq) #inert
							(eval% (cons% $aux exprseq) d))
						($set! se $aux
							$vau/e% (weaken-environment se) (&head .&tail) d
								$if (null? tail) (eval% head d)
									(($lambda% #ignore
										(eval% (cons% $aux tail) d))
											(eval% head d))))
					(() make-standard-environment);
				test-sequence $sequence
			);
			subinfo "with __make-stdenv";
			$let ()
			(
				$def! $sequence
					(wrap ($vau% (&$seq2) #ignore $seq2
						($def! $aux $vau/e% (make-environment
							(() get-current-environment) (() __make-stdenv))
							(&head .&tail) d
							($if (null? tail) (eval head d)
								($seq2 (eval% head d)
									(eval% (cons% $aux tail) d))))
						($vau/e% (make-environment (() lock-current-environment)
							(() __make-stdenv)) &exprseq d
							($if (null? exprseq) #inert
								(eval% (cons% $aux exprseq) d)))
					))
					($vau (head second) d (wrap
						($vau #ignore #ignore (eval second d))) (eval head d));
				test-sequence $sequence
			);
			subinfo "with copy-environment";
			$let ()
			(
				$def! $sequence
					(wrap ($vau% (&$seq2) #ignore $seq2
						($def! $aux $vau/e% (make-environment
							(() get-current-environment) (() copy-environment))
								(&head .&tail) d
							($if (null? tail) (eval head d)
								($seq2 (eval% head d)
									(eval% (cons% $aux tail) d))))
						($vau/e% (make-environment (() lock-current-environment)
							(() copy-environment)) &exprseq d
							($if (null? exprseq) #inert
								(eval% (cons% $aux exprseq) d)))
					))
					($vau (head second) d
						(wrap ($vau #ignore #ignore (eval% second d)))
							(eval% head d));
				test-sequence $sequence
			)
		);
		subinfo "with copy-enviornment invalid";
		$let ()
		(
			$def! $sequence
				(wrap ($vau% (&$seq2) #ignore $seq2
					($def! $aux $vau/e% (() copy-environment)
						(&head .&tail) d ($if (null? tail) (eval% head d)
							($seq2 (eval% head d)
								(eval% (cons% $aux tail) d))))
					($vau/e% (() copy-environment) &exprseq d
						($if (null? exprseq) #inert
							(eval% (cons% $aux exprseq) d)))))
				($vau (head second) d (wrap
					($vau #ignore #ignore (eval% second d))) (eval head d))
		);
	))
	((eqv? i 10) (
		info "list operations";
		subinfo "list?";
		$check list? (list 1);
		$check list? (cons% 2 ());
		subinfo "list? trailing irregular representation";
		$check-not list? (cons% 3 nilvr);
		subinfo "empty list calls: list and list%";
		$expect () () list;
		$expect () () list%;
		subinfo "empty list calls: list* and list*%;" " fixed since b897";
		$expect () list* ();
		$expect () list*% ();
		subinfo "list*% reference preserving;" " fixed derivation since b953";
		$check reference? (list*% id);
		subinfo "list underlying opeative evaluations";
		$expect 1 eval (list*% (unwrap list%) 1) (() get-current-environment);
		$expect 1 eval
			(list*% () (unwrap list%) 1) (() get-current-environment);
		$expect (cons 1 2)
			eval ((unwrap list%) (cons 1 2)) (() get-current-environment);
		$expect (cons 1 2)
			eval (list*% (unwrap list) 1 2) (() get-current-environment);
		$expect (cons 1 2)
			eval (list*% (unwrap list%) 1 2) (() get-current-environment);
		subinfo "improper list cons";
		$expect (cons (list 1 2) 4) cons (list 1 2) 4;
		$expect (cons (list 1 2) 4) cons q-li q-b;
		subinfo "sanity test of forward-first%";
		$rem
		(
			"NOTE:", " The following implementations are not conforming.";
			$defl%! forward-first% (&list-appv &appv &l)
				($lambda% ((&x .)) (forward! appv) ($move-resolved! x)) l;
			$defl%! forward-first% (&list-appv &appv &l)
				($lambda% ((&x .)) eval% (list% (forward! appv)
					($move-resolved! x)) (() make-environment)) l;
			$defw%! forward-first% (&list-appv &appv &l) d
				($lambda% ((&x .))
					eval% (list% (forward! appv) ($move-resolved! x)) d) l
		);
		$let ()
		(
			$defl%! first-test (%l0)
				($lambda% (fwd) forward-first%
					(wrap ($vau% (&x) d
						$sequence (eval ($quote l0) d) (forward! (forward! x))))
						(fwd l0))
				($if (bound-lvalue? ($resolve-identifier l0)) id expire);
			subinfo "forward-first% (previously forward-list-first%);"
				" fixed derivation since b898";
			$expect "should not be evaluated"
				first (rest% (forward-first% idv (idv
					(list% (list% raise-error "should not be evaluated") 1))));
			$expect 1 first-test (list 1 2)
		);
		$let ((a list 2 3))
		(
			subinfo "list lvalue elements accesses";
			$expect 2 first a;
			$expect 2 first (id a);
			$check reference? (first a);
			$check reference? (first% (list% q-a 2));
			subinfo "first return value conversion;" " fixed since b939";
			$check-not reference? (first (list% q-a 2));
			subinfo "list xvalue elements accesses";
			$expect 2 first (as-const (expire a));
			$expect 2 first (expire a);
			$expect 2 list-length
				($let ((li q-li2)) (restv (expire (as-const li)); li));
			$expect 1 list-length
				($let ((li q-li2)) (restv (expire li); li));
			$expect-moved first a
		);
		subinfo "first forwarding;" " fixed derivation since b939";
		$let ()
		(
			$defl! test (f)
			(
				$def! li list% (expire (as-const q-a)) 2;
				$check-not modifiable? (f li);
				$check unique? (f li);
				$expect 1 f li
			);
			test first;
			test first&
		);
		subinfo "firstv copy elision on xvalues;" " fixed since b939";
		$let ((li list% (() make-nocopy))) $def! b firstv (expire li);
		$let ((li list% q-a q-a))
		(
			subinfo "first& propagation of nonmodifiable reference elements;"
				"fixed derivation since b953";
			$let ((li list% q-a)) $check-not modifiable? (first& (as-const li));
			subinfo "rest& propagation of nonmodifiable reference elements;"
				"fixed native since b953";
			$check-not modifiable? (rest& (as-const li))
		);
		subinfo "list access";
		list% q-li q-li2
			(idv (first q-li)) (restv q-li)
			(idv (first q-li2)) (restv q-li2)
			(first q-li) (rest% q-li)
			(first q-li2) (rest% q-li2)
			(first& q-li) (rest& q-li)
			(first& q-li2) (rest& q-li2)
			(list*% q-a 1 2 (list% q-a 1 2))
			(list-concat (list 1 2) q-li)
			(append q-li (list 1 2) q-li2 (list 3 q-a))
			($let ((&q-b q-a)) q-b)
			($let* ((&q-b q-a) (&q-c q-b)) q-c)
			(first& (first& q-li3))
			(rest& (first& q-li3))
			(first (rest& q-li3))
			(rest% (rest& q-li3));
		subinfo "improper list access";
		$expect (cons% 2 3) restv (list*% 1 2 3);
		$check eq? (rest% (cons% 2 q-a)) q-a;
		subinfo "rest& improper list access;" " fixed native since b953";
		$let ((ca cons 1 2)) $expect 2 idv (rest& ca);
		subinfo "subpair reference referent;" " fixed since b952";
		$let* ((pr cons 1 2) ((#ignore .&xs) pr)) $check-not uncollapsed? xs;
		subinfo "list lambda binding";
		apply ($lambda% (&x &y) x) (list% q-li q-li2);
		subinfo "list modification";
		$let ()
		(
			set-first! q-li q-b;
			$expect (list q-b 2) q-li;
			set-first%! q-li q-b;
			$expect (list q-b 2) q-li;
			set-first! q-li 5;
			$expect (list 5 2) q-li;
			set-first%! q-li 7;
			$expect (list 7 2) q-li;
			set-rest! q-li q-li;
			$expect (list 7 7 2) q-li;
			set-rest%! q-li (list 3 1);
			$expect (list 7 3 1) q-li;
			set-rest%! q-li (idv q-li2);
			$expect (cons 7 (list 3 1)) q-li;
			$expect (list (list 7 3 1) 7 3 1) cons% q-li (idv q-li);
			$expect 3 first& (first& q-li4);
			set-first! (first& q-li4) (list () 2);
			$expect (list 1) (rest& (first& q-li4));
			$expect (list (list (list () 2) 1) 3 4 5) q-li4
		);
		subinfo "list modification temporary preservation;" " fixed since b944";
		$let ()
		(
			$defl! test (f)
			(
				$let ((&li list 1 2))
				(
					set-rest%! li (list 3);
					$expect (list 1 3) li;
					forward! li;
					$expect-moved li
				)
			);
			test set-rest!;
			test set-rest%!
		);
		subinfo "list-push-front!";
		$let ((li list 2 3))
		(
			list-push-front! li 1;
			$expect (list 1 2 3) li
		);
		subinfo "list-push-front! preserving references;"
			" fixed derivation since b950";
		$let ((li list% q-a 3))
		(
			list-push-front! li 1;
			$check (reference? (first% (rest% li)))
		)
	))
	((eqv? i 11) (
		info "logical operations";
		subinfo "not?;" " fixed since b899";
		$check eqv? ($let ((f #f)) not? f) (not? #f);
		subinfo "non-strict logical operations";
		$check () $and;
		$check-not () $or;
		$check-not $and #f #f;
		$check $or #f #t;
		$expect 2 $and 1 2;
		$expect 1 $or 1 #f;
		$expect 2 $or #f 2 #f 3;
		subinfo "$or (previously $or?);" " fixed since b884";
		$or #f #f (string->symbol "evaluate-once") #f;
		subinfo "strict logical operations";
		$check () and;
		$check-not () or;
		$check-not and #f #f;
		$check or #f #t;
		$expect 2 and 1 2;
		$expect 1 or 1 #f;
		$expect 3 or #f 2 #f 3
	))
	((eqv? i 12) (
		info "list utilities";
		subinfo "first-null?";
		$check-not first-null? (list 1 2);
		$check first-null? (list () 2);
		$let ()
		(
			$def! i 42;
			$def! el ();
			$check-not first-null? (list i 2);
			$check first-null? (list el 2)
		);
		subinfo "sublists eagar logical operations";
		$expect (list 3 #f 2 #f)
			list (and 1 2 3) (and 1 #f 3) (or #f 2 #f) (or #f #f);
		subinfo "accr";
		accr (list (list "2") (list "3")) null? () first% rest%
			($lambda% (&x &y) accr (forward x) null? y first% rest% cons%);
		subinfo "foldr1";
		$expect (list "2" "3")
			foldr1 list-concat () (list (list "2") (list "3"));
		subinfo "map1";
		$expect (list% id 2 3) map1 id (list% id 2 3);
		$expect (list "afx" "bfx" "cfx")
			map1 ($lambda (&s) ++ s "fx") (list "a" "b" "c");
		$let* ((&x 1) (li list% x))
		(
			$expect (list 1) (map1 forward! li);
			$expect-moved first li
		);
		subinfo "list-concat";
		$expect (list "2" "3") list-concat (list "2") (list "3");
		$check-not reference? (list-concat () q-e);
		subinfo "append";
		$expect (list% "2" id) append (list "2") (list% id);
		subinfo "list algorithm safety";
		$expect (list% (list% 1 2 3) (list% 1 2 3)) list%
			($let () ($def! li list 1 2 3; map1 id li))
			($let () ($def! li list 1 2 3; append li));
		subinfo "list extraction";
		$let (($list unwrap list))
		(
			$defl! test-lextr (list-extract%)
			(
				$defl%! list-extract-first! (&l)
					list-extract% (map1 expire (rlist l)) first;
				$defl%! list-extract-rest%! (&l)
					list-extract% (map1 expire (rlist l)) rest%;
				$defl! make-test-list () $list (x + 1 2) (y idv) (z id id);
				$def! li () make-test-list;
				$expect ($list x y z) list-extract-first! li;
				$expect ($list (() + 1 2) (() idv) (() id id)) li;
				$def! li () make-test-list;
				$expect ($list (+ 1 2) (idv) (id id)) list-extract-rest%! li;
				$expect ($list (x) (y) (z)) li;
				$expect ($list x y z) list-extract-first! (() make-test-list);
				$expect ($list (+ 1 2) (idv) (id id))
					list-extract-rest%! (() make-test-list);
				subinfo "list-extract-first";
				$expect ($list x y z) list-extract-first (() make-test-list);
				subinfo "list-extract-rest%";
				$expect ($list (+ 1 2) (idv) (id id))
					list-extract-rest% (() make-test-list)
			);
			subinfo "list extraction #1";
			$defw%! list-extract% (&l &extr) d
				foldr1 ($if ($lvalue-identifier? l)
					($lambda% (&x &xs) cons% (apply extr (list% x) d)
						(move! xs))
					($lambda% (&x &xs) cons% (apply extr (list% (expire x)) d)
						(move! xs))) () l;
			test-lextr list-extract%;
			subinfo "list extraction #2";
			$defw%! list-extract% (&l &extr) d
				accr l null? () ($lambda% (&l)
					apply forward-first% (list% extr (expire l)) d) rest% cons%;
			test-lextr list-extract%;
			subinfo "list extraction #3";
			$defl! list-extract% (&l &extr) map1 extr (forward! l);
			test-lextr list-extract%;
		);
		subinfo "list-extract-first value";
		$let* ((i 1) (l0 list% i 2) (li list% (as-const l0) (list 3 4)))
			$check-not modifiable? (first% (list-extract-first li));
		$let ((li list (list 3 4)))
		(
			subinfo "list-extract-first unexpected move;"
				" fixed native since b940";
			$expect (list 3) (list-extract-first li);
			$check-not moved? (first (first li));
			subinfo "list-extract-rest% unexpected move;"
				" fixed native since b940";
			$expect (list (list 4)) (list-extract-rest% li);
			$check-not null? (rest% (first li))
		);
		$let ((a list "2" "3"))
		(
			subinfo "mapn";
			$expect (list "246" "357")
				mapn 2 ++ a (list "4" "5") (list "6" "7");
			subinfo "map-fromn";
			$expect (list "42" "53")
				map-fromn ++ (list "4" "5") a;
			$expect (list "421")
				map-fromn ++ (list "4" "5") a (list "1");
			subinfo "map-strict";
			$expect (list "246" "357")
				map-strict ++ a (list "4" "5") (list "6" "7");
			subinfo "map";
			$expect (list "42" "53")
				map ++ (list "4" "5") a;
			$expect (list (list (list 2)) (list (list 4)) (list (list 6)))
				map list-restv (list (list 1 2) (list 3 4) (list 5 6));
			$expect (list 5 7 9)
				map + (list 1 2 3) (list 4 5 6);
			$expect (list "421")
				map ++ (list "4" "5") a (list "1");
			subinfo "filter";
			$expect (list "2" "3" "1" "2")
				filter ($lambda (s) not? (string-empty? s))
					(append a (list "" "1" "" "2"))
		);
		subinfo "assv";
		$expect (list 1 "l")
			assv 1 (list (list 9 2) (list 1 "l") (list 3 4) (list 1 3));
		$expect (list q-a "l") assq q-a (list
			(list 9 2) (list 1 "m") (list% q-a "l") (list 3 4) (list% q-a 3));
		subinfo "memv?";
		$check memv? 1 (list 1 2 4);
		subinfo "reduce";
		reduce (list% q-li q-li2 q-li q-li2) ($lambda% (&x &y) x) q-li;
		$expect 10 reduce (list 1 2 3 4) + 5;
		subinfo "foldr";
		$let ((a0 0) (a1 1))
		(
			$expect (list 6 1)
				foldr ($lambda (&x &y) list (+ x (first y)) x) (list% 0 a0 0)
					(list a1 2 3);
			$expect (list 16 1)
				foldr ($lambda (&x &y &s) list (+ (+ x y) (first s)) x)
					(list% 0 a0 0) (list% a1 2 3) (list% 4 5 a1)
		);
		info "well-formed list function definitions";
		$let ()
		(
			$defl! fold* (&kons &head .&tail) $if (null? tail) head
				(kons head (apply fold* (cons kons tail)));
			$defl! xlist* (.&xs) apply fold* (cons cons xs)
		);
		subinfo "reduce";
		$let ()
		(
			$defl! |> (&f &g) $lambda/e% ($bindings/p->environment
				((() make-standard-environment)) (&f (forward f))
				(&g (forward g))) (&x) (forward g) ((forward f) (forward x));
			$defl! double (n) * n 2;
			$defl! increment (n) + n 1;
			$expect 42 double (increment (double (double 5)));
			$expect 42 (|> (|> (|> double double) increment) double) 5;
			$defl! pipes (fs x) (reduce fs |> idv) x;
			$expect 42 pipes (list double double increment double) 5
		);
		subinfo "map-reverse and for-each-ltr tail calls;" " fixed since b856";
		$expect #inert for-each-ltr ($lambda .) (list ());
		$expect (list ()) map-reverse ($lambda .) (list ())
	))
	((eqv? i 13) (
		info "binding operations";
		subinfo "tail calls;" " fixed since b856";
		$expect () $let ();
		subinfo "$let";
		$expect 5 $let ((&x 2) (&y 3)) + x y;
		subinfo "$let*";
		$expect 4 $let* ((&x 2) (&y x)) + x y;
		subinfo "$letrec";
		$expect 3 $letrec ((x + 0 1) (x 2) (x - 4 1)) x;
		subinfo "$letrec%; fixed since b939";
		$check reference? ($letrec% () q-a);
		subinfo "$letrec*";
		$expect (list 1 2 3) $letrec ((x + 0 1) (y 2) (z - 4 1)) list x y z;
		subinfo "local bindings with static environments";
		$expect "cd"
			$let/e (list std.strings std.io) ()
				(puts (++ "a" "b"); (++ "c" "d"));
		$expect "cd"
			$let/e (derive-environment std.strings std.io) ((d "d"))
				(puts (++ "a" "b"); (++ "c" d));
		subinfo "binding lvalue lists; " "fixed native since b940";
		$let ((n 42))
		(
			$defl! test-let ($let)
			(
				$expect 42 eval% (list% $let () idv n)
					(() get-current-environment);
				$def! bd list% (list% ($quote a) 1) (list% ($quote b) 2);
				$expect n eval% (list% $let bd idv n)
					(() get-current-environment)
			);
			for-each-ltr test-let
				(list $let $let% $let* $let*% $letrec $letrec%)
		);
		subinfo "binding noncopyable objects;" " fixed since b914";
		$let ()
		(
			$defl! test-let-case ($let &x can-copy)
			(
				"reference support in parameter trees; fixed since b915";
				$def! n 42;
				$def! li1 list% ($quote a) n;
				$def! bindings list% li1 (list% ($quote t) (move! x));
				$if can-copy
				(
					$def! backup bindings;
					eval% (list% $let (as-const bindings) move! ($quote t))
						(() get-current-environment);
					$expect bindings backup;
					eval% (list% $let bindings move! ($quote t))
						(() get-current-environment);
					$expect bindings (id backup)
				);
				eval% (list% $let (expire bindings) move! ($quote t))
					(() get-current-environment);
				display/newline bindings
			);
			$defl! test-let ($let)
			(
				test-let-case $let (list make-nocopy) #t;
				test-let-case $let (() make-nocopy) #f
			);
			for-each-ltr test-let
				(list $let $let% $let* $let*% $letrec $letrec%)
		);
		subinfo "binding noncopyable objects on new environment;"
			" fixed since b918";
		$let ()
		(
			$defv! $bp-seq (&parents .&bindings) d $sequence
				($def! (res bref) list (apply make-environment
					(map1 ($lambda% (x) eval% x d) parents)) (rulist bindings))
				(eval% (list $set! res (list-extract-first bref)
					(list* () list (list-extract-rest% bref))) d)
				res;
			$defv! $bp-let (&parents .&bindings) d
				$let ((res apply make-environment (map1 ($lambda% (x) eval% x d)
					parents)) (bref rulist bindings))
					$let ((#ignore eval% (list $set! res
						(list-extract-first bref) (list* () list
						(list-extract-rest% bref))) d)) res;
			$defl! test-b-case ($b &x can-copy)
			(
				$def! n 42;
				$def! li1 list% ($quote a) n;
				$def! bindings list% li1 (list% ($quote t) (move! x));
				$if can-copy
				(
					$def! backup bindings;
					eval% (list*% $b (as-const bindings))
						(() get-current-environment);
					$expect bindings backup;
					eval% (list*% $b bindings) (() get-current-environment);
					$expect bindings backup
				);
				eval% (list*% $b (expire bindings))
					(() get-current-environment);
				display/newline bindings
			);
			$defl! test-bp ($bp)
			(
				$defv! $b (.&bindings) d eval (list* $bp () (move! bindings)) d;
				test-b-case $b (list make-nocopy) #t;
				test-b-case $b (() make-nocopy) #f
			);
			for-each-ltr test-bp (list $bindings/p->environment $bp-seq $bp-let)
		);
		subinfo "empty lvalues bindings environment;" " fixed since b927";
		$let ((el ()))
			$expect 42 eval% (list% $let el 42) (() get-current-environment);
		info "binding operations";
		subinfo "simple environment separation";
		$let ()
		(
			$def! count 0;
			$def! ez () get-current-environment;
			$defl! ax () $set! ez count + 1 count;
			() ax;
			$expect 1 count
		);
		subinfo "$let count";
		$let ()
		(
			$def! count $let ((&counter 0))
			(
				$def! self () get-current-environment;
				$lambda/e (lock-environment self) ()
				(
					$set! self counter + counter 1;
					counter
				)
			);
			$expect 1 () count
		);
		subinfo "$let count in new environment";
		$let ()
		(
			$def! count $let
				((&se make-environment (() get-current-environment)))
			(
				$set! se (wenv counter) list (weaken-environment se) 0;
				$lambda/e se ()
				(
					$set! wenv counter + counter 1;
					counter
				)
			);
			$expect 1 () count
		);
		subinfo "$letrec count";
		$let ()
		(
			$def! count $letrec
			(
				(self () get-current-environment)
				(counter 0)
			)
			(
				$lambda/e (lock-environment self) ()
				(
					$set! self counter + counter 1;
					counter
				)
			);
			$expect 1 () count
		);
		subinfo "$bindings->environment";
		$let ()
		(
			$def! e $bindings->environment (x 1) (y 2);
			$expect 3 eval (list + (string->symbol "x") (string->symbol "y")) e
		);
		subinfo "let* environment encapsulation";
		$expect (list 3 2 1)
			$let* ((count 0) (env (() get-current-environment)))
				map ($lambda (#ignore) (($set! env count add1 count); count))
				(list 9 8 7)
	))
	((eqv? i 14) (
		info "imports and $provide!";
		subinfo "$provide!";
		$let ()
		(
			$def! ee $provide! (a) $def! a 42;
			$def! el ();
			$def! b ($lambda (() a ()) a) () a el;
			$expect 42 a;
			$expect 42 b
		);
		subinfo "$import! and $import&!";
		$let ()
		(
			$import&! std.strings ++;
			$check-not modifiable? ++;
			$import! std.strings ++;
			$check modifiable? ++;
			$import! std.strings &++;
			$check-not modifiable? ++
		);
		subinfo "$provide! for trailing symbols;" " fixed since b920";
		$let ()
		(
			$def! e $provide! (.a .b)
			(
				$def! .a 42;
				$def! .b 43
			);
			list .a .b
		);
		subinfo "$import! for trailing symbols;" " fixed since b920";
		$let ()
		(
			$def! e () make-environment;
			$set! e .a 42;
			$set! e .b 43;
			$import! e .a .b;
			list .a .b
		)
	))
	((eqv? i 15) (
		info "std.continuations";
		$let ()
		(
			$import&! std.continuations
				call/1cc continuation->applicative apply-continuation;

			$expect 42 call/1cc ($lambda . 42);
			$let ((a 43)) $expect 43 call/1cc ($lambda . a);
			$expect (list 44) call/1cc ($lambda (&k) (
				(continuation->applicative (move! k))
					($sequence (display/newline "ready to call k") 44);
				raise-error "Failed to skip."));
			$expect 45 call/1cc ($lambda (&k) (
				apply-continuation (move! k)
					($sequence (display/newline "ready to call k") 45);
				raise-error "Failed to skip."))
		)
	))
	((eqv? i 16) (
		info "std.promises";
		$import! std.promises
			promise? memoize $lazy $lazy% $lazy/d $lazy/d% force;
		subinfo "value category preservation";
		$let ((p1 $lazy% idv unit))
		(
			$expect unit force unit;
			$expect unit force ($lazy p1);
			force (expire p1);
			$expect-moved force ($lazy p1)
		);
		subinfo "force idempotence";
		$let ((a unit))
		(
			$def! p $lazy a;
			$expect (force p) force p;
		);
		subinfo "lifting safety";
		$let ()
		(
			$defl! me ()
			(
				$def! e () make-environment;
				$set! e x 42;
				e
			);
			$expect 42 force ($lazy/d (() me) x);
			$expect 42 force ($lazy% $lazy/d (() me) x);
			$expect 42 force ($lazy $lazy/d% (() me) x)
		);
		subinfo "test #1 (as RnRK)";
		$let ()
		(
			$def! env_tmp_ $provide! (get-count pb) $sequence
				($def! count 5)
				($defl! get-count () count)
				($def! p ($let ((self () get-current-environment))
					(
						$set! self saved_ () lock-current-environment;
						$lazy $if (<=? count 0) count
							($sequence
								($set! self count (- count 1))
								(force p)
								($set! self count (+ count 2))
								count)
					)
				))
				($def! pb box% p);
			$expect 5 () get-count;
			$expect 0 force (unbox pb);
			$expect 10 () get-count;
		);
		subinfo "test #2 (as RnRK)";
		$let ()
		(
			puts "expect output: single line of \"*\"";
			$def! p1 $lazy (puts "*");
			$def! p2 $lazy p1;
			force p2;
			force p1
		);
		subinfo "test #3 (as RnRK)";
		$let ()
		(
			$def! maxn 3;
			$defl! stream-filter (p? s)
			(
				$lazy/d (() lock-current-environment) $let ((v (force s)))
				(
					$if (null? v) v
					(
						$let ((s stream-filter p? (first (rest& v))))
							$if (p? (first& v)) (list (first v) s) s
					)
				)
			);
			$defl! from (n)
				$lazy/d (() lock-current-environment) list n (from (+ n 1));
			force (stream-filter ($lambda (n) eqv? n maxn) (from 0))
		);
		subinfo "self-modifying promises;" " fixed since b924";
		$let ()
		(
			"Regression:",
				"This is incapable in RnRK without first-class references.";
			puts "expect output: single line of \"*\"";
			"NOTE", "This tests the memoization clause set the correct place.",
				"Instead of reusing the old one, the decapsulated object",
				" should be accessed immediately.";
			$def! p $lazy $sequence (puts "*") (assign! p ($lazy (puts "#")));
			force p
		);
		subinfo "binding noncopyable objects;" " fixed since b924";
		$expect 42 force (eval (list $lazy $sequence (() make-nocopy) 42)
			(() get-current-environment));
		subinfo "resolved referencing shared state move;" " fixed since b925";
		$let ()
		(
			$def! p1 $lazy unit;
			$def! p2 $lazy% p1;
			$let* ((a force p2) (b force p1) (c force (move! p2)))
				$expect (list unit unit unit unit) list a b c (force p1)
		)
	))
	((eqv? i 17) (
		info "std.math";
		subinfo "number predicates";
		$let ()
		(
			$import&! std.math
				number? complex? real? rational? integer? exact-integer?;

			$check number? 123;
			$check-not number? "123";
			$check complex? 3;
			$check real? 3;
			$check real? (- 0 2);
			$check real? +inf.0;
			$check real? +nan.0;
			$check-not rational? -inf.0;
			$check rational? (- 0 3);
			$check integer? 3;
			$check exact-integer? 32;
			$check-not exact-integer? ""
		);
		subinfo "arithmetic operations";
		$let ()
		(
			$import&! std.math
				>=? zero? positive? negative? odd? even? max min abs;

			$check =? 2 2;
			$check <? 1 2;
			$check <? 1 +inf.0;
			$check-not <? 2 1;
			$check-not <? 1 -nan.0;
			$check-not >? 2 2;
			$check >=? 2 2;
			$check-not <=? 2 1;
			$check zero? 0;
			$check-not zero? 1;
			$check positive? 1;
			$check-not positive? 0;
			$check-not negative? 1;
			$check-not negative? 0;
			$check odd? 1;
			$check odd? (- 0 1);
			$check even? 0;
			$check-not even? (- 0 1);
			$expect 2 max 1 2;
			$expect -inf.0 min -inf.0 2;
			$expect 0 abs 0;
			subinfo "odd? for negative odd flonums" " fixed since b937";
			$check odd? -1.0
		);
		$let ()
		(
			$import&! std.math floor/ floor-quotient floor-remainder truncate/
				truncate-quotient truncate-remainder - /;

			subinfo "integer divisions (R7RS cases)";
			$expect (list 2 1) floor/ 5 2;
			$expect 2 floor-quotient 5 2;
			$expect 1 floor-remainder 5 2;
			$expect (list -3 1) floor/ -5 2;
			$expect -3 floor-quotient -5 2;
			$expect 1 floor-remainder -5 2;
			$expect (list -3 -1) floor/ 5 -2;
			$expect -3 floor-quotient 5 -2;
			$expect -1 floor-remainder 5 -2;
			$expect (list 2 -1) floor/ -5 -2;
			$expect 2 floor-quotient -5 -2;
			$expect -1 floor-remainder -5 -2;
			$expect (list 2 1) truncate/ 5 2;
			$expect 2 truncate-quotient 5 2;
			$expect 1 truncate-remainder 5 2;
			$expect (list -2 -1) truncate/ -5 2;
			$expect -2 truncate-quotient -5 2;
			$expect -1 truncate-remainder -5 2;
			$expect (list -2 1) truncate/ 5 -2;
			$expect -2 truncate-quotient 5 -2;
			$expect 1 truncate-remainder 5 -2;
			$expect (list 2 -1) truncate/ -5 -2;
			$expect 2 truncate-quotient -5 -2;
			$expect -1 truncate-remainder -5 -2;
			$expect (list 2.0 -1.0) truncate/ -5.0 -2;
			$expect 2.0 truncate-quotient -5.0 -2;
			$expect -1.0 truncate-remainder -5.0 -2;
			subinfo "32-bit integer underflow";
			$def! imin - -2147483647 1;
			$def! neg-imin - 0 imin;
			$expect imin / imin 1;
			$expect neg-imin / imin -1;
			$expect imin floor-quotient imin 1;
			$expect neg-imin floor-quotient imin -1;
			$expect imin truncate-quotient imin 1;
			$expect neg-imin truncate-quotient imin -1;
		);
		subinfo "AABB square number search";
		$let ()
		(
			$import&! std.math
				truncate/ truncate-quotient truncate-remainder add1;

			$rem (
				"The following Kernel code conforms to PTC.";
				($define! solve ($lambda (n) ($let ((x (* n n)))
					($if ($and (=? (div x 1000) (mod (div x 100) 10))
					(=? (div (mod x 100) 10) (mod x 10))) x (solve (+ n 1))))))
				(solve 80)
			);
			"The following code requires trucating quotient and remainder.";
			$defl! solve (n) $let* ((x * n n) ((xq100 xr100) truncate/ x 100))
				$if ($and (=? (truncate-quotient x 1000)
					(truncate-remainder xq100 10))
					(=? (truncate-quotient xr100 10) (truncate-remainder x 10)))
				x (solve (add1 n));
			$expect 7744 solve 80
		)
	))
	((eqv? i 18) (
		info "std.strings";
		subinfo "strings and symbols";
		$let ()
		(
			$import! std.strings string->symbol symbol->string;

			$expect "a" symbol->string ($quote a),
			$expect "a" symbol->string (string->symbol "a")
		);
		subinfo "string split";
		$let ()
		(
			$import! std.strings string-split;

			$expect (list "a" "b" "c") string-split "a;b;c" ";",
			$expect (list "a" "b" "" "c") string-split "a.b..c" "."
		);
		subinfo "regular expressions";
		$let ()
		(
			$import! std.strings string->regex regex-match? regex-replace;

			$let ((pattern string->regex "\?"))
			(
				$check-not regex-match? "xxxxx" pattern,
				$check-not regex-match? "xx?xx" pattern,
				$check regex-match? "xx?xx" (string->regex "xx\?xx"),
				$check regex-match? "xx?xx" (string->regex ".+\?x+"),
				$expect "1111" regex-replace "????" pattern "1"
			)
		)
	))
	((eqv? i 19) (
		info "std.system";
		subinfo "eval-string and eval-unit";
		$let ()
		(
			$import! std.system eval-string eval-unit get-current-repl;
			eval-string "1" (() get-current-environment);
			eval-unit "1;" (() get-current-repl)
		)
	))
	(#t "No case found.")
);

$defl! teste (i)
(
	$cond
	((eqv? i 1) (
		"Expected: ParameterMismatchE:",
			" Insufficient term found for list parameter.";
		map-strict ++ (list "4" "5") (list "1")
	))
	((eqv? i 2) (
		"Expected: BadIdentifier: Unknown identifier: 'x'.";
		$let ((&x 2) (&y x)) + x y
	))
	((eqv? i 3) (
		"Expected: BadIdentifier: Unknown identifier: 'x'.";
		$letrec ((&x 2) (&y x)) + x y
	))
	((eqv? i 4) (
		"Expected: NPLExceptionE: Wrapping count overflow detected.";
		$let ()
		(
			$defl! fn (w x) fn
				($lambda (x) w (w x))
				(puts (itos (get-wrapping-count x)); w (w x));
			fn wrap (wrap-n fn (- 0 42))
		)
	))
	((eqv? i 5) (
		"UB: Checked by NPL_NPLA_CheckTermReferenceIndirection.";
		"Expected on check: InvalidReferenceE:",
			"Invalid reference found on indirection,"
			" probably due to invalid context access by a dangling reference.";
		$let ()
		(
			$defl%! foo (&x) x;
			display/newline (foo 42)
		)
	))
	((eqv? i 6) (
		"Expected: BadIdentifier: Unknown identifier: 'a'.";
		$let ()
		(
			$def! (a b)
				list (($lambda (x y) x y y) a b) (($lambda (x y) x x y) b a)
		)
	))
	((eqv? i 7) (
		"Expected: InvalidReference: Invalid cyclic reference found.";
		$let ()
		(
			$defrec! (a b) list (($lambda (x y) x y y) a b)
				(($lambda (x y) x x y) b a)
		)
	))
	(#t "No case found.")
);

$defl! test-nested ()
(
	info "The following case test the hosted nested call safety.";
	subinfo "term destroy;" " fixed since b916";
	$defl! make-list (l n)
		$unless (eqv? n 0) (list% (make-list (move! l) (- n 1)));
	$expect 1 list-length (make-list () 50000);
	subinfo "term copy;" " fixed since b944";
	$def! x make-list () 200000;
	$def! y x;
	$expect 1 list-length y
);

$defl! test-ptc (i)
(
	"The following cases are for PTC.",
		" Unless otherwise specified, the execution of the case will not stop",
		" with constant memory consumption.";
	$cond
	((eqv? i 1) (
		info "PTC $if";
		$let ()
		(
			$defl! f (n) $if #t (f n);
			f 1
		);
		$let ()
		(
			$defl! f (n) $if #t (f n) 2;
			f 1
		);
		$let ()
		(
			$defl! f (n) $if #f 3 (f n);
			f 1
		);
		$let ()
		(
			$defl! f (x .y) $if (null? y) (f x #t) (f (x));
			f 1
		)
	))
	((eqv? i 2) (
		info "PTC eval";
		$let ()
		(
			$def! l list (string->symbol "f") (string->symbol "x");
				$defl! f (x) (eval l (() get-current-environment));
			f 1
		);
		$let ()
		(
			$def! l list () (string->symbol "f");
			$def! c () get-current-environment;
			$defl! f () eval l c;
			() f;
		);
	))
	((eqv? i 3) (
		info "PTC combiner with recursive function lvalues";
		$defv! $f () #ignore () $f; () $f;
		$defv! $f () d eval (list () $f) d; () $f;
		$defv! $f (x) d eval x d; $defl! f (n) $f (f n); f ();
		$defl! f () () f; () f;
		$defl! f (n) f n; f 1;
		$defl! f (&n) f n; f 42;
		$defl! f (n) f (- n 1); f 1;
		$defl! f ((x y)) f (list x y); f (list 1 2);
		$defrec! (f g) (list ($lambda (x) (g (- x 1)))
			($lambda (x) (f (- x 1)))); f 1;
		$defl! g (x) f x; $defl! f (n) g n; f 1;
		$defv! $g (x) d f (eval x d); $defl! f (n) $g n; f 1;
		subinfo "lifetime invalid @ b823", "fixed @ b826",
			"see YSLib %ChangeLog";
		$defv! $seq2 (x y) d eval (list $sequence x y) d;
			$defl! f (n) $seq2 n (f (- n 1)); f 1;
		$defv! $seq2 (x y) d eval (list $sequence x y) (lock-environment d);
			$defl! f (n) $seq2 n (f (- n 1)); f 1;
	))
	((eqv? i 4) (
		info "PTC combiner with comsumed recursive function prvalues";
		$defl! f (n) ($vau (x) d eval (list f x) d) n; f 1;
		$defl! f (n) ($vau (x) d eval x d) (f n); f 1;
		$defl! f (n) ($vau (x y) d eval (list $sequence x y) d) n (f n); f 1;
		$defl! f (n)
			($vau (x y) d eval (list $sequence x y) (lock-environment d)) n
				(f n);
		f 1;
		subinfo "PTC combiner with saved recursive function prvalues",
			"since b861r0c", "cf. $2019-06 @ YSLib %Documentation::Workflow";
		$defl! f (n) ($lambda (x) f x) n; f 1;
		$defl! f (n) ($vau (x) d f (eval x d)) n; f 1;
	))
	((eqv? i 5) (
		info "PTC combiners with wrap/unwrap";
		$let ()
		(
			$defv! $f () #ignore () (wrap $f);
			() $f
		);
		$let ()
		(
			$defl! f () () (unwrap f);
			() f
		)
	))
	((eqv? i 6) (
		info "PTC $sequence (lvalue/rvalue/eval)";
		$let ()
		(
			$defl! f (n) $sequence n (f (- n 1));
			f 1
		);
		$let ()
		(
			$defl! f (n) (n; (f (- n 1)));
			f 1
		)
	))
	((eqv? i 7) (
		info "PTC $cond";
		$let ()
		(
			$defl! f (n) $cond (#f 3) (#t f n);
			f 1
		);
		$let ()
		(
			$defl! f (&n) $cond (#f 3) ((eqv? n 1) f n);
			$def! a 1;
			f a
		)
	))
	((eqv? i 8) (
		info "PTC $quote";
		$def! c () get-current-environment; $defl! f () eval ($quote (() f)) c;
		() f
	))
	((eqv? i 9) (
		info "PTC id";
		$defl%! f (&x) f (id x);
		f f
	))
	((eqv? i 10) (
		info "PTC idv";
		$defl! f (&x) f (idv x);
		f f
	))
	((eqv? i 11) (
		info "PTC $and";
		$defl! f (n) $and #t (f n);
		f #t
	))
	((eqv? i 12) (
		info "PTC $or";
		$defl! f (n) $or #f (f n);
		f #f
	))
	((eqv? i 13) (
		info "PTC apply";
		$defl! f (n) apply f (list n);
		f 1
	))
	((eqv? i 14) (
		info "PTC accl";
		accl () ($lambda (.) #f) () idv idv ($lambda (x .) x)
	))
	((eqv? i 15) (
		info "PTC $let";
		subinfo "since b829", "fixed @ b861", "see YSLib %ChangeLog";
		$defl! f (x) $let () f x;
		f ()
	))
	((eqv? i 16) (
		info "PTC call/1cc";
		subinfo "case translated from DOI:10.1145/93548.93554";
		$let ()
		(
			$import&! std.continuations call/1cc;

			$defl! looper () call/1cc ($lambda (k) () looper);
			() looper		
		)
	))
	((eqv? i 17) (
		info "PTC promises as klisp #3, with less n value;"
			" fixed @ b862 as $let";
		$let ()
		(
			$import! std.promises $lazy/d force;
			$defl! stream-filter (p? s) ($lazy/d (() lock-current-environment)
				$let ((v (force s)))
					($if (null? v) v
						($let ((s stream-filter p? (first (rest& v))))
							$if (p? (first& v)) (list (first v) s) s)));
			$defl! from (n)
				$lazy/d (() lock-current-environment) list n (from (+ n 1));
			force (stream-filter ($lambda (n) eqv? n 1000) (from 0))
		)
	))
	((eqv? i 18) (
		"PTC example", "klisp failed",
			"see https://bitbucket.org/AndresNavarro/klisp/issues/12";
		$let ()
		(
			$sequence
				($def! f ($lambda (n) ((($vau (x y) e (eval ($sequence x y) e))
				n (f n))))) (f 1)
		)
	))
	((eqv? i 19) (
		info "This case can terminate.";
		subinfo "TCO from ECMAScript compat-table."
			" Value 1e6 shrinked to 100000 to reduce execution time."
			" For debug configurations, better a smaller value, e.g. 10000.";
		$def! recn 100000;
		"https://github.com/kangax/compat-table/blob/gh-pages/data-es6.js#L20";
		subinfo "Expect: \"foo\" + LF.";
		$let ()
		(
			$defl! f (n) $if (<=? n 0) "foo" (f (- n 1));
			puts (f recn)
		);
		"https://github.com/kangax/compat-table/blob/gh-pages/data-es6.js#L50";
		subinfo "Expect: \"foo\" + LF + \"foo\" + LF.";
		$let ()
		(
			$def! (f g) list ($lambda (n) $if (<=? n 0) "foo" (g (- n 1)))
				($lambda (n) $if (<=? n 0) "bar" (f (- n 1))); puts (f recn);
			puts (g (+ recn 1))
		)
	))
	(#t "No case found.")
);

$let ()
(
	info "Sanity:" " strong normalized, well-formed";
	eval (list ($lambda x () ($lambda x $if)) 1) (() make-environment)
);

$def! test-case-num 19;
$def! teste-case-list list 1;
$defl! test-in (&l) for-each-ltr test l;
$defl! test-range (first last) test-in (iota-range first last);
$defl! test-seq (i) test-in (iota i);
